## 秒杀系统设计思路
在秒杀系统设计中，最主要难点在于解决高并发下的并发请求抢锁问题。我这里主要有几种案。

### 方案1 乐观锁
在DB“库存”记录中维护一个版本号，在更新“库存”操作进行前先去DB中获取当前版本号，在更新库存的事务提交时，检查该版本号是否被其他操作修改。如果版本没被修改，则提交事务，且版本号加1；如果版本号已经被其他事务修改，则回滚事务，并报告给上层。

这个方案解决了“并发请求抢锁”的问题 
这个方案的缺点是DB性能较差

### 方案2 内存操作
将“实时扣减库存”的动作上移到内存中操作，内存操作成功后直接给逻辑服务器返回成功，然后异步DB持久化 

这个方案的优点分析：  
该方案用内存代替磁盘操作，提高了并发性能


这个方案的缺点分析：  
在内存操作成功但DB持久化失败、或者内存故障的情况下，DB持久化会丢失数据,要想解决内存故障，解决方案是搭建一套高可用的缓存系统


注意：这个系统的设计关注点在于数据层对外的高性能和高可用，至于数据何时会持久化到DB中不是秒杀系统的主要矛盾点，所以我们应该尽量将精力花在数据层的高性能和高可用上面。

#### 总结
| 方案 | 先到先得 | 性能 | 缺点 |  
| - | :-: | -: |  :- |  
| 乐观锁 | 不是先到先得 | 性能不好 | 会带来大数据量的无效更新请求、事务回滚，给DB造成不必要的压力 |   
| 内存操作 | 先到先得 | 性能好 | 内存故障会丢失数据 |  

| 方案 | 先到先得 | 性能 | 缺点 | 
| - | :-: | -: | -: | 
| 乐观锁 | Gryffindor| 90 | 90 | 
| Hermione Granger | Gryffindor | 100 | 90 | 
| Draco Malfoy | Slytherin | 90 | 90 | 





